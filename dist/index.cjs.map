{"version":3,"sources":["../src/index.ts","../src/can-i-email-fetcher.ts","../src/config.ts","../src/services/update.service.ts","../src/types/api-response.checker.ts","../src/services/frontmatter.service.ts","../src/services/github-fetch.service.ts"],"sourcesContent":["export * from './can-i-email-fetcher';\n\nexport * from './types/api-response.type';\n","import EventEmitter from 'events';\n\nimport { DATA_UPDATED_EVENT, UpdateService } from './services/update.service';\n\nimport type { Config } from 'config';\nimport type { ApiResponse, Nicenames } from 'types/api-response.type';\n\nexport class CanIEmailFetcher {\n    private readonly updateService: UpdateService;\n    private readonly eventEmitter: EventEmitter;\n\n    private _currentApiResponse: ApiResponse | null = null;\n\n    constructor(config: Config) {\n        this.updateService = new UpdateService(config);\n        this.eventEmitter = new EventEmitter();\n\n        this.updateService.on(DATA_UPDATED_EVENT, (data) => {\n            this._currentApiResponse = data;\n\n            this.eventEmitter.emit('update', data);\n        });\n    }\n\n    public onUpdate(callback: (data: ApiResponse) => void): void {\n        this.eventEmitter.on('update', callback);\n    }\n\n    public offUpdate(callback: (data: ApiResponse) => void): void {\n        this.eventEmitter.off('update', callback);\n    }\n\n    public get currentApiResponse(): ApiResponse | null {\n        return this._currentApiResponse;\n    }\n\n    public get currentNicenames(): Nicenames | null {\n        return this._currentApiResponse?.nicenames || null;\n    }\n}\n","export type Config = {\n    githubToken?: string;\n} & Partial<DefaultConfig>;\n\ntype DefaultConfig = {\n    updateInterval: number; // in hours\n    repoUrl: string;\n};\n\nexport const defaultConfig: DefaultConfig = {\n    updateInterval: 24,\n    repoUrl: 'https://github.com/hteumeuleu/caniemail',\n};\n","import { defaultConfig } from 'config';\nimport EventEmitter from 'events';\nimport { load as loadYaml } from 'js-yaml';\nimport { basename } from 'path';\n\nimport {\n    FeatureTypeChecker,\n    NicenamesTypeChecker,\n} from '../types/api-response.checker';\nimport { frontmatterParse } from './frontmatter.service';\nimport { GithubFetchService } from './github-fetch.service';\n\nimport type { Config } from 'config';\nimport type { ApiResponse, Feature, Nicenames } from 'types/api-response.type';\n\nexport const DATA_UPDATED_EVENT = 'dataUpdated';\n\nexport class UpdateService extends EventEmitter {\n    private lastUpdate: Date | null = null;\n    private readonly fetchService: GithubFetchService;\n\n    constructor(private config: Config) {\n        super();\n\n        this.fetchService = new GithubFetchService(this.config);\n\n        this.fetchApiResponse();\n        setInterval(() => this.checkForUpdates(), 3600000);\n    }\n\n    async checkForUpdates(): Promise<void> {\n        const now = new Date();\n\n        if (\n            !this.lastUpdate ||\n            now.getTime() - this.lastUpdate.getTime() >\n                (this.config.updateInterval || defaultConfig.updateInterval) *\n                    3600000 // Convert hours to milliseconds (1 hour = 3600000 ms)\n        ) {\n            this.lastUpdate = now;\n            this.fetchApiResponse();\n        }\n    }\n\n    public async fetchApiResponse(): Promise<void> {\n        const nicenames = await this.fetchNicenames();\n        const features = await this.fetchFeatures();\n\n        if (nicenames && features) {\n            const apiResponse: ApiResponse = {\n                last_update_date: new Date().toISOString(),\n                nicenames: nicenames,\n                data: features,\n            };\n\n            this.emit(DATA_UPDATED_EVENT, apiResponse);\n        }\n    }\n\n    private async fetchNicenames(): Promise<Nicenames | null> {\n        const file = await this.fetchService.getContent('_data/nicenames.yml');\n\n        if (\n            file.type === 'file' &&\n            file.content &&\n            file.encoding === 'base64'\n        ) {\n            const fileContent = Buffer.from(\n                file.content,\n                file.encoding,\n            ).toString('utf-8');\n\n            const nicenames = loadYaml(fileContent);\n\n            if (NicenamesTypeChecker.isNicenames(nicenames)) {\n                return nicenames;\n            } else {\n                console.error('Invalid nicenames data');\n                return null;\n            }\n        } else {\n            console.error('Failed to fetch nicenames');\n            return null;\n        }\n    }\n\n    private async fetchFeatures(): Promise<Feature[]> {\n        const directory = await this.fetchService.getContent('_features');\n\n        if (directory.type === 'dir') {\n            const files = directory.entries;\n            const markdownFiles = files.filter(\n                (file) =>\n                    file.type === 'file' &&\n                    file.name.endsWith('.md') &&\n                    !file.name.startsWith('_'),\n            );\n\n            const featureContents = await Promise.all(\n                markdownFiles.map(async (filePointer) => {\n                    const file = await this.fetchService.getContent(\n                        filePointer.path,\n                    );\n\n                    if (\n                        file.type === 'file' &&\n                        file.content &&\n                        file.encoding === 'base64'\n                    ) {\n                        const fileContent = Buffer.from(\n                            file.content,\n                            file.encoding,\n                        ).toString('utf-8');\n\n                        const temp = frontmatterParse(fileContent, {\n                            ignoreDuplicateKeys: true,\n                        }).attributes;\n\n                        const feature = {\n                            slug: basename(file.name, '.md'),\n                            description: null,\n                            url: '',\n                            tags: [],\n                            keywords: null,\n                            test_url: null,\n                            test_results_url: null,\n                            notes: null,\n                            notes_by_num: null,\n                            links: null,\n                            ...(typeof temp === 'object' ? temp : {}),\n                        };\n\n                        if (FeatureTypeChecker.isFeature(feature)) {\n                            return feature;\n                        } else {\n                            console.error('Invalid feature data');\n                            return null;\n                        }\n                    }\n\n                    return null;\n                }),\n            ).then((results) => results.filter((result) => result !== null));\n\n            return featureContents;\n        }\n\n        return [];\n    }\n}\n","import type { Feature, Nicenames } from './api-response.type';\n\nexport class FeatureTypeChecker {\n    static isFeature(obj: any): obj is Feature {\n        return (\n            obj &&\n            typeof obj === 'object' &&\n            'slug' in obj &&\n            'title' in obj &&\n            'description' in obj &&\n            'url' in obj &&\n            'category' in obj &&\n            'tags' in obj &&\n            'keywords' in obj &&\n            'last_test_date' in obj &&\n            'test_url' in obj &&\n            'test_results_url' in obj &&\n            'stats' in obj &&\n            'notes' in obj &&\n            'notes_by_num' in obj &&\n            'links' in obj\n        );\n    }\n}\n\nexport class NicenamesTypeChecker {\n    static isNicenames(obj: any): obj is Nicenames {\n        return (\n            obj &&\n            typeof obj === 'object' &&\n            'family' in obj &&\n            'platform' in obj &&\n            'support' in obj &&\n            'category' in obj\n        );\n    }\n}\n","import { load, loadAll } from 'js-yaml';\n\nconst optionalByteOrderMark = '\\\\ufeff?';\nconst platform = typeof process !== 'undefined' ? process.platform : '';\nconst pattern =\n    '^(' +\n    optionalByteOrderMark +\n    '(= yaml =|---)' +\n    '$([\\\\s\\\\S]*?)' +\n    '^(?:\\\\2|\\\\.\\\\.\\\\.)\\\\s*' +\n    '$' +\n    (platform === 'win32' ? '\\\\r?' : '') +\n    '(?:\\\\n)?)';\n\nconst regex = new RegExp(pattern, 'm');\n\ninterface ExtractorResult {\n    attributes: Record<string, unknown>;\n    body: string;\n    bodyBegin: number;\n    frontmatter?: string;\n}\n\ninterface ParseOptions {\n    ignoreDuplicateKeys?: boolean;\n}\n\nfunction computeLocation(match: RegExpExecArray, body: string): number {\n    let line = 1;\n    let pos = body.indexOf('\\n');\n    const offset = match.index + match[0].length;\n\n    while (pos !== -1) {\n        if (pos >= offset) {\n            return line;\n        }\n        line++;\n        pos = body.indexOf('\\n', pos + 1);\n    }\n\n    return line;\n}\n\nexport function frontmatterParse(\n    string: string,\n    options?: ParseOptions,\n): ExtractorResult {\n    const match = regex.exec(string);\n    if (!match) {\n        return {\n            attributes: {},\n            body: string,\n            bodyBegin: 1,\n        };\n    }\n\n    const yamlContent = match?.[match.length - 1]?.replace(/^\\s+|\\s+$/g, '');\n\n    if (!yamlContent) {\n        return {\n            attributes: {},\n            body: string,\n            bodyBegin: 1,\n        };\n    }\n\n    let attributes: Record<string, unknown> = {};\n\n    if (options?.ignoreDuplicateKeys) {\n        loadAll(\n            yamlContent,\n            (doc) => {\n                attributes = {\n                    ...attributes,\n                    ...(doc as Record<string, unknown>),\n                };\n            },\n            { json: true },\n        );\n    } else {\n        attributes = (load(yamlContent) as Record<string, unknown>) || {};\n    }\n\n    const body = string.replace(match[0], '');\n    const line = computeLocation(match, string);\n\n    return {\n        attributes,\n        body,\n        bodyBegin: line,\n        frontmatter: yamlContent,\n    };\n}\n","import axios from 'axios';\nimport { defaultConfig } from 'config';\n\nimport type { Config } from 'config';\nimport type {\n    RepositoryContentDirectory,\n    RepositoryContentFile,\n} from '../types/github-api';\n\nconst GITHUB_API_URL = 'https://api.github.com';\nconst GITHUB_API_VERSION = '2022-11-28';\n\nexport class GithubFetchService {\n    private readonly repoOwner: string;\n    private readonly repoName: string;\n    private readonly githubToken: string | undefined;\n\n    constructor(private config: Config) {\n        if (config.githubToken) {\n            this.githubToken = config.githubToken;\n        }\n\n        const result = this.extractOwnerAndRepoFromGithubUrl(\n            this.config?.repoUrl ?? defaultConfig.repoUrl,\n        );\n\n        if (result) {\n            const { owner, repo } = result;\n            this.repoOwner = owner;\n            this.repoName = repo;\n        } else {\n            throw new Error('Failed to extract owner and repo from URL');\n        }\n    }\n\n    public async isPermissiveLicense(): Promise<boolean> {\n        const apiUrl = `${GITHUB_API_URL}/repos/${this.repoOwner}/${this.repoName}/license`;\n\n        try {\n            const response = await axios.get(apiUrl, {\n                headers: this.getAuthHeaders(),\n            });\n\n            return ['mit', 'unlicense', 'apache-2.0'].includes(\n                response.data.license.key,\n            );\n        } catch (error) {\n            console.error('Error fetching license information:', error);\n            return false;\n        }\n    }\n\n    public async getLastUpdate(): Promise<string | null> {\n        const apiUrl = `${GITHUB_API_URL}/repos/${this.repoOwner}/${this.repoName}/commits?per_page=1`;\n\n        try {\n            const response = await axios.get(apiUrl, {\n                headers: this.getAuthHeaders(),\n            });\n\n            return response.data[0].commit.committer.date;\n        } catch (error) {\n            console.error('Error fetching last update:', error);\n            return null;\n        }\n    }\n\n    public async getContent(\n        path: string,\n    ): Promise<RepositoryContentDirectory | RepositoryContentFile> {\n        const apiUrl = `${GITHUB_API_URL}/repos/${this.repoOwner}/${this.repoName}/contents/${path}`;\n\n        try {\n            const response = await axios.get(apiUrl, {\n                headers: {\n                    ...this.getAuthHeaders(),\n                    Accept: 'application/vnd.github.object+json',\n                },\n            });\n\n            return response.data;\n        } catch (error) {\n            console.error('Error fetching file content from GitHub:', error);\n            throw new Error('Failed to fetch file content');\n        }\n    }\n\n    private extractOwnerAndRepoFromGithubUrl(url: string): {\n        owner: string;\n        repo: string;\n    } | null {\n        const urlObj = new URL(url);\n        const owner =\n            urlObj.hostname === 'github.com'\n                ? urlObj.pathname.split('/')[1]\n                : null;\n        const repo = urlObj.pathname.split('/')[2];\n\n        if (owner && repo) {\n            return { owner, repo };\n        } else {\n            return null;\n        }\n    }\n\n    private getAuthHeaders() {\n        const headers: Record<string, string> = {\n            Accept: 'application/vnd.github+json',\n            'X-GitHub-Api-Version': GITHUB_API_VERSION,\n        };\n\n        if (this.githubToken) {\n            headers['Authorization'] = `Bearer ${this.githubToken}`;\n        }\n\n        return headers;\n    }\n}\n"],"mappings":"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","names":["src_exports","__export","CanIEmailFetcher","__toCommonJS","import_events","defaultConfig","import_events","import_js_yaml","import_path","FeatureTypeChecker","__name","obj","NicenamesTypeChecker","import_js_yaml","optionalByteOrderMark","platform","pattern","regex","computeLocation","match","body","line","pos","offset","__name","frontmatterParse","string","options","yamlContent","attributes","doc","import_axios","GITHUB_API_URL","GITHUB_API_VERSION","GithubFetchService","config","result","defaultConfig","owner","repo","__name","apiUrl","response","axios","error","path","url","urlObj","headers","DATA_UPDATED_EVENT","UpdateService","EventEmitter","config","GithubFetchService","__name","now","defaultConfig","nicenames","features","apiResponse","file","fileContent","loadYaml","NicenamesTypeChecker","directory","markdownFiles","filePointer","temp","frontmatterParse","feature","FeatureTypeChecker","results","result","CanIEmailFetcher","__name","config","UpdateService","EventEmitter","DATA_UPDATED_EVENT","data","callback"]}